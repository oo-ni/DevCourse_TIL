- LMS 강의 각자 듣고 정리하여 발표

1교시 : LMS 클라우딩 컴퓨팅 파트 시청 후 정리

2교시 : LMS 클라우딩 컴퓨팅 파트 시청 후 정리

3교시 : LMS 소프트웨어 공학 파트 시청 후 정리

4교시 : LMS 소프트웨어 공학 파트 시청 후 정리

5교시 : 각자 맡은 부분 발표

6교시 : 알고리즘

7교시 :

8교시 :

[스터디 방법 tip]

1. 전체가 동시에 공부할 컨텐츠와 분량, 시간을 정한다.

2. 그 중 한사람씩 자신이 정리할 파트를 맡는다.(각자 할당 시간은 5~10분 정도로)

3. 각자 해당 분량을 공부한다.(사람마다 시간이 남거나 부족해도 개의치 않기로 한다.)

4. 모여서 한명씩 순서대로 자기 파트를 정리해서 설명한다.

(이 때, 다른 사람들이 이미 안다고 너무 뭉뚱그려 설명하지 않도록 유의한다.)

5. 듣는 사람은 이미 공부한 부분이라도 자신에게 도움이 될 내용등을 다시 정리하며 듣는다.

6. 설명한 부분에 대해 궁금한 질문, 유익한 질문, 첨부하면 좋은 내용등을 보탠다

### 클라우드 컴퓨팅

- 김수민

  ### 클라우드 컴퓨팅

    <aside>
    💡 클라우드에 구축된 인프라를 활용하는 서비스나, 이를 사용하는 것을 클라우드 컴퓨팅이라고 한다.

    </aside>

  ### IT 패러다임

    - 메인 프레임 (60~80)
        - 터미널, 시분할 시스템(batch processing)
    - 클라이언트-서버(90)
        - 저비용 단말기를 이용하여 많은 사용자들이 서버 자원에 접근
    - 그리드 컴퓨팅(2000)
        - 값싼 장비들을 대량으로 연결, 웹 기반의 응용을 통해 접근
        - 중앙서버 보다는 나누어서 실행되고 접근하는 방식
    - 클라우드 컴퓨팅(2005~)
        - On-demand로 인프라 구성 및 활용
        - On-demand

          외부 서비스 공급자가 데이터를 관리하는 방식



    Amazon이 내부 사용 자원을 이용해 클라우드 사업을 개시하면서부터 본격 활용
    
    ### 클라우드 컴퓨팅의 이점
    
    - 민첩성
        - IT 리소스의 구동이 빨라짐
        - AWS 생각해보면 가상 서버를 생성하고 실행하는데 수분밖에 안걸림
    - 탄력성
        - 비즈니스 요구에 따라 리소스 운용의 확장/축소가 용이 (동적 스케일링)
        - scale out / scale in 이 용이 → 서버를 추가하거나 감소시켜 시스템을 확장, 축소하는 것
    - 비용 절감
        - 서버를 보유하는데 들어가는 비용 (TCO)보다 사용한만큼만 지불하는게 합리적이고 비용이 절감됨
    - 가용성
        - 빠른 배포와 무중단 교체가 가능
    
    ### 단점
    
    - 고비용
        - 활용하지 않고 있어도 리소스를 점유하고 있으면 과금이 될 수 있다. → ex 탄력적 ip
        - learning curve가 높다.
    
    ### 개방형/폐쇄형 클라우드
    
    - 개방형 클라우드 (Public Cloud)
        - 클라우드를 사용하길 원하는 사용자가 요금을 지불하고 이용할 수 있도록 일반 대중에게 서비스를 제공함
        - 규모가 작은 기업이 내부 IT 관리 부담을 줄이기 위해 이용
        - AWS, GCP(google), Azure(Microsoft)
    - 폐쇄형 클라우드(Private Cloud)
        - 자사 IT 시스템 인프라 구축을 목적으로, 클라우드 서비스를 자체 운영함
        - 혹은 인프라 구축, 운용을 아웃소싱 (외주)
        - 대규모 기업의 IT 인프라를 안정적으로 운용하는데 적합
- 노관태

  ## 클라우드 컴퓨팅의 핵심 원칙

    - 공유된 컴퓨팅 자원

      ### 자체 호스팅과 외주 자원 이용의 비교

        - 자체 호스팅 : 설비투자비용 발생, 운영에 전담 인력 배정으로 인건비 부담
        - 외주 자원 이용: CAPEX(설비투자비용) → OPEX(운영비용) 전환

      ### 관리 호스팅 방식과 클라우드 컴퓨팅의 비교

        - 클라우드 모델의 눈에 띄는 차별점은 “대부분의 경우 초기 셋업 비용 자체가 필요없음”
        - 관리 호스팅에 드는 연간 비용은 보통 자체 호스팅의 설비투자비용과 비슷하거나 조금 낮은 정도
    - 컴퓨팅 자원의 가상화
        - 클라우드 서비스를 이용하지 않는다고 하더라도 서버 가상화는 여러 가지 경제적 이점을 가짐
        - 가상화 기술의 적용으로 자원 공동 사용의 이점을 극대화
    - 자원 수요 증감에 대한 탄력성
        - 클라우드 컴퓨팅 인프라는 API를 통한 자동화 기능 제공
        - 컴퓨터 자원 가상화에 의한 민첩성을 통해 여유 있게 시스템 규모를 준비해야 하는 부담을 경감.
    - 자원 활용 방식의 자동 제어
        - 클라우드 컴퓨팅 인프라는 API를 통한 자동화 기능 제공
        - 물리적인 서버의 추가/제거/이동 또는 수작업 설치/테스트 등은 없어야 한다.
    - 사용량에 따른 과금
        - 관리 호스팅 : 초기 셋업 비용과 연간 약정 비용 과금
        - 클라우드 컴퓨팅 : 초기 셋업 비용 없음. 사용량에 따라 이용료 과금
        - 클라우드 컴퓨팅 비용 모델은 새로운 비즈니스 기회를 창출
- 류희수

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/c600c956-49ce-4062-bddf-c451f4fa3e3c/Untitled.png)

  `IaaS (Infrastructure as a Service)`

    - > IaaS는 가상화된 컴퓨팅 자원(서버, 저장소, 네트워크)을 인터넷을 통해 제공하는 서비스

  특징 : 사용자는 물리적인 하드웨어를 소유할 필요 없이 가상 머신을 통해 필요한 컴퓨팅 자원을 임대하여 사용할 수 있음 (GCP, aws의 ec2등)

  `PaaS (Platform as a Service)`

    - > PaaS는 애플리케이션 개발 및 실행 환경을 제공하여 개발자가 소프트웨어를 개발, 테스트, 배포할 수 있게 하는 플랫폼 서비스.
      (소프트웨어의 개발을 돕는 플랫폼 Google App Engine, Microsoft Azure App Services, Heroku.)
      -> api를 제공하기도 하고 배포를 도와주기도 함

  `SaaS (Software as a Service)`

  고객이 활용하는 서비스 모델
  사용자는 소프트웨어의 설치, 업데이트, 유지보수를 직접 할 필요 없이 즉시 사용할 수 있음.
  gmail, office, docs등, slack

  클라우드 전환의 이득

    1. capex -> opex 비용 이득(설계 비용 -> 자금 비용) 으로 이점이 있음
    2. 서버 구매나 설치의 필요를 제거하여 민첩하게 진행 가능
    3. 경쟁우위를 점할 수 있는 time -to-martket (빠르게 시장에 내놓을 수 있음)
    4. 우수하고 강력한 보안 ->(자사가 아닌 클라우드 서비스 회사의 전문적인 보안과, 사고예방을 담당함)
       (보안이 강력하다는 것보다는 자사에서 따로 보안적인 인력을 사용하는 것보다 전문적인 보안전문가들이 클라우드쪽에 상주하고 있다가 맞는 표현인 것 같슴돠)

  `Collocation` -> 네트워크 장치를 사지만 (데이터 센터를 관리하고 있는 업체)는 별도로 있음
  다른 사람의 장치에 내 장치를 설치하여 비용만 지불한다.
  장점 : (전력 공급, 냉방, 물리적인 비용이 좀 줄어듬)

  `Managed Hosting` : it인프라 소스도 호스팅을 보유하고 있는 업체를 사용(임대)
  (서버, 네트워크 장비.. 등등) 냉방 회선 등등 전부다 이용만 하고 요금만 내면 됨 : Capex : 0but OPEX 는 조금 더 높음

  `Cloud Computing` : capex : 0, Opex가 managed Hosting 보다는 적음

  적합한경우 :

  변동성이 큰 경우 -> 우리 회사에서 굳이? 만드는 것 보다는 클라우드 서비스가 좋음

  좀 민첩하고, 백업등, 회사에 주는 가치가 그렇게 크지 않은 경우
  (비전략적인 경우)

  부적합한 경우 :

    1. 레거시가 있으면 굳이 클라우드로?

    2. 극단적으로 중요한 것, 공장의 자동화 제어, it의 세밀한 부분(의료등)

    3. 기밀 데이터를 다루는 응용 (클라우드에 저장되면 완전 삭제를 보장할 방법x)

- 양아영

  # 마이크로서비스 아키텍처

  : 소프트웨어 운용 시스템 설계하는 디자인 패턴 중 하나

    - 클라우드 컴퓨팅 - 마이크로서비스 아키텍처는 필요 충분, 필요, 충분 조건이 아님!

      BUT 결합했을 때 이점과 유연한 특징이 큼


    ## 마이크로 서비스 아키텍처
    
    - 시스템들을 독립적으로 배포할 수 있는 서비스들로 잘게 나누어 구성
        - 비즈니스 기능 단위로 나눔
        - 각 서비스는 독립적인 팀이 담당
        - 단지 소프트웨어 운용 시스템의 아키텍처 뿐만 아니라 조직적인 측면도 다루고 있음
        - 각 서비스는 잘 정의된 API를 통해 통신
    
    (장점)
    
    - 서비스 단위로 변경하고 독립적으로 배포할 수 있다 → 소프트웨어의 delivery performance 높아짐
    - API 사용으로 기능을 재사용하고 조합하여 신규 기능 만들 수 있다
    - 아키텍처를 조직 구조에 맞게 정렬 가능
    - 서비스 단위로 스케일 아웃 가능
    - 장애가 퍼져 대형 장애로 이어지는 것 방지 (국지적 장애로 마무리)
    - 서비스 별로 다른 기술 사용할 수 있어 신규 기술 적용하기 쉬움
    
    ### 모놀로식(전통적인) vs 마이크로아키텍처
    
    business logic / data access layer가 비즈니스 기능 단위로 나눠져 있음
    
    ## 마이크로서비스 아키텍처의 적용
    
    - 소프트 웨어 개발-배포 과정과 절차를 경량화하는 것 중요
        - 개발-배포-테스트 주기를 짧게 → CI/CD(자동화) 중요
        - 변경 관리의 부담을 경감하여 라이프 사이클 반복 과정 가속화
            
            → delivery performance 높아짐
            
    - 장애 대응의 효율 또한 중요한 요소
    - 해결하고자 하는 문제는 기술적인 것이 아님, 비기술적인 영역임
        - 조직이 어떤 방식을 택해서 일을 해 나갈 것이냐
    - 스프린트 중심의 애자일 개발 방법 및 지속적 인도 적용이 동력
    
    ## 아키텍처 - 프로세스 - 조직
    
    ⇒ 비기술적인 부분이 중요하게 작용

- 윤건우

  ### MSA의 특징

    - 시스템을 독립적으로 배포할 수 있는 서비스들로 구성
        - 비즈니스 기능 단위로 나누고 독립적인 팀들이 담당
        - 각 서비스는 잘 정의된 API를 통하여 통신
    - 장점
        - 서비스 단위로 변경하고 독립적으로 배포할 수 있다.
        - API로 기능을 재사용하고 조합하여 신규 기능을 만들 수 있다.
        - 아키텍처를 조직 구조에 맞게 정렬할 수 있다.
        - 서비스 단위로 스케일 아웃할 수 있다.
        - 서비스의 장애가 다른 서비스에 퍼지는 것을 차단하여 대형 장애를 방지할 수 있다.
        - 서비스 별로 다른 기술을 사용할 수 있으며, 이러한 특성 때문에 신규 기술을 적용하기 쉽다.
    - 단점
        - 서비스 간 통신이 필요하며, 서로 간 연결 구축 및 관리의 복잡성이 증가한다.
        - 초기 개발 및 통신 등에 시간이 소요된다.

  ### MSA의 적용

    - 소프트웨어 개발-배포 과정과 절차를 경량화하는 것이 중요
        - 개발-배포-테스트 주기를 짧게 → CI/CD (자동화)가 중요해진다.
        - 변경 관리의 부담을 경감하여 iteration 가속화
    - 장애 대응의 효율 또한 중요한 요소
    - 해결하고자 하는 문제는 기술적인 것이 아니다.
    - 스프린트 중심의 애자일 개발 방법 및 지속적 인도 적용이 동력

  → 대규모 및 복잡한 프로젝트, 시스템을 독립적으로 개발하고 확장해야 하는 경우에 사용하기 좋다.

  ### 모놀리식 아키텍처와 비교

  ![https://medium.com/javanlabs/micro-services-versus-monolithic-architecture-what-are-they-e17ddc8d3910](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/566e61f7-44f5-4d8d-bd6a-a13ceca72763/Untitled.png)

  https://medium.com/javanlabs/micro-services-versus-monolithic-architecture-what-are-they-e17ddc8d3910

    - 모놀리식 아키텍처의 장점
        - 초기 개발에 유리하며 빠르게 프로토타입을 개발할 수 있다.
        - 필요한 모든 기능을 한 번만 호출하기 때문에 복잡한 통신 없이 직접 사용할 수 있다.
    - 모놀리식 아키텍처의 단점
        - 코드 베이스가 커질수록 복잡해지고 유지관리 및 확장이 어려워진다.
        - 일부 기능을 수정하거나 업데이트를 하려면 전체 애플리케이션을 재배포해야한다.

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/03bac77b-9281-4651-ae23-ac8c62612dd3/Untitled.png)

  ### 아키텍처-프로세스-조직 🔄

  지속적으로, 빠르고 자주, 안정적으로 SW딜리버리

    - 아키텍처
        - MSA
    - 프로세스
        - DevOps
        - CI/CD
        - Lean process
    - 조직
        - 작고, 자율적이고, 범기능적이고 충분한 권한을 가진 팀들의 조합

  ### 아키텍처 예시

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/459c4153-179a-478e-8446-b23dc5aba988/Untitled.png)

  ### 개인적 평가

    - 장점 : 기능별 단위 테스트와 배포가 자유롭다. (연속적으로 돌아가야하는 시스템에서는 꼭 필요함)

  이전 프로젝트에서 프로토타입 시연을 할때, jwt로직에 문제가 생겨서 인증서버가 제대로 안돌아간적이 있었음 → 당연히 연결된 회원서버, 주문서버 쪽 API에서도 안돌아가는 애들이 생김 → 근데 발표 시작 → 일단 다른 서버쪽 기능을 미리 시연함 (상품 검색, 필터링, faq, 알림 기능 같은) → 발표중에 백엔드팀 모여서 인증서버 고쳐서 배포함 → 나머지 로그인, 상품 주문, 마이페이지 등 남은 기능 다 시연 성공.

    - 단점 : 더럽게 비싸다.

  위에 있는 아키텍처로 3개월 운용 기준 프론트 서버에서 20만원, 백엔드 서버에서 38만원, CI/CD쪽에서 거의 15만원..? 나왔던 것 같다. 그냥 객체지향 지켜서 멀티모듈로 구현해도 학생 수준 프로젝트에서는 충분히 좋을 것 같다고 생각했다.

- 이정우

  **클라우드 컴퓨팅의 허와 실 (쉬어가는 타임)**

  IT 서비스 아키텍쳐 패러다임을 보면

  개발조직, 테스트조직, 운영조직 등의 비즈니스 접근방법 즉, 조직을 어떻게 구성하고 어떤 프로세스에따라 비즈니스에 좋은 임팩트를 줄수있는 업무 최적화 그 업무에 참여하는 사람들의 마인드셋 그리고 업무 만족도 이런것들을 향상시키는 도구이자 환경으로 클라우드를 보는 관점이 중요하다.

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/2373601d-fc70-4161-b4c2-46eaf1c0ecc8/Untitled.png)

    - On-Premise = 자체구축시스템

  이렇게 보았을때 클라우드를 다 사용하는것이 이득이라고 볼수 있지만,, 실상은

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/73d31264-c764-400b-8d7e-46dcd24ebd6d/Untitled.png)

  시간이 지날수록 자체시스템 보다 비용이 증가한다. (Lock-In 지점)


### 소프트웨어공학

- 김수민

  **소프트웨어 공학의 두가지 뜻**

    - **높은 품질의 소프트웨어를 효율적으로** 개발하는 방법을 탐구하는 학문/분야
    - 소프트웨어를 제품화함에 있어 적용할 수 있는 **품질보증 및 개선 활동을 규정**하는 프로세스

    <aside>
    💡 소프트웨어 개발 전체 생명 주기에서 요구사항 분석, 설계, 구현, 테스트, 유지보수 등과 같은 과정을 체계적으로 수행하며, 효율적이고 안정적인 소프트웨어를 개발하는 방법

    </aside>

  **소프트웨어 품질이 중요한 이유**

    - 중요 임무를 수행하는 시스템
        - 인명 손실이나 재해 등 큰 위험이 소프트웨어의 결함으로부터 야기될 수 있음
    - 일반적인 시스템
        - 소프트웨어 결함은 비즈니스에 큰 타격을 줄 수 있음
        - 정보 유출, 제품 리콜, 서비스 다운타임으로 인한 고객 유실

  **소프트웨어 품질 보증 어려움**

    - 검증을 위한 프로토타입 제작과 양산 단계를 구별하기 어려움
        - 하드웨어는 시제품을 만들 어 검증하지만, 소프트웨어는 개발 활동이 곧 생산활동
    - 코드 변경과 개선이 끊임없음
    - 통제된 공정을 적용하기 어려움
        - 많은 개발자들이 코드에 접근, 잦고 유연한 릴리스
- 노관태

  ### 소프트웨어 개발 프로세스 성숙 모델

    - 소프트웨어 개발 조직의 역량을 평가하는 모델
        - CMMI: 미국 국방부
        - SPICE: ISO/IEC 15504애 의해 규정

  제조업을 중심으로 안정적이고 적절한 모델들이 만들어져왔다.

  ### CMMI Levels

    1. Initial : 결과를 만들어내기는 하나, 일정이 지연되고 예산이 초과되는 일이 빈번하다
    2. Managed: 프로젝트가 계획, 수행, 측정, 제어할 수 있다.
    3. Defined: 프로젝트를 넘어서 조직 전체가 제어된다. 능동적이다.
    4. Quantitatively Managed: 조직이 내-외부 이해 관계자의 요구에 예측 가능하고 일정한 성능 개선 목표 데이터 중심으로 구성합니다.
    5. Optimizing: 이상적. 지속적인 개선 활동을 할 준비가 되어있고, 성숙한 프로세스를 갖추고 있으며 큰 노력 없이 소프트웨어 품질 보증을 할 수 있다.

  소프트웨어 품질 보증을 위한 노력이 조직 및 문화적으로 얼마나 힘든지 알 수 있다.

  2024/5/8 기준

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/e3827e11-4db7-4616-a90a-c4458faf6543/Untitled.png)

  (2024/5/8 기준, 유효기간 3년)**국내 CMMI level 5 인증 취득 기관 :**

  **국방과학연구소, ㈜풍산, 한국항공우주산업, 한화시스템, 한화에어로스페이스, 현대 로템, 휴니드테크놀러지스, LIG 넥스원**

  ### 소프트웨어 개발 및 유지관리 프로세스

    - 개발방법론: 구조적, 정보공학적, 객체지향적, 컴포넌트 위주
    - 소스코드 형상관리: 형상항목을 식별 및 변경을 통제, 기록 (git)
    - 단계별 산출물 관리: 프로세스에 따른 필수산출물의 제작 및 검수, 유지보수
    - 요구사항 관리: 요구사항을 중요하게 여기고 관리해나가는 일
    - 테스트 및 검증:  단위, 통합, 시스템, 인수

  ### 소프트웨어 개발 및 품질관리의 중요 측면

    - Tool의 선택과 절차의 고도화보다는 SDLC에 참여하는 조직원들의 마음가짐이 중요
        - 규정된 절차와 지침을 준수
        - 점진적 개선을 위한 활동에 적극 참여
        - 모범사례로부터 교휸을 얻고, 우리 조직에 가장 맞는 프로세스를 채택.
        - 제품은 곧 회사의 얼굴. 제품의 신뢰성과 경제성을 확보하려는 노력.

- 류희수

  개발론 : 시스템을 개발하기 위해 어떠한 방법을 택할 것인가? (기술 스택이 아님)

  공통적인 요소는 많지만 개발조직의 특성 및 여건에 맞게 조정,
  재정의하여 적합한 방법을 택하는 것이 중요함.

  **폭포수 모델**

  요구 -> 디자인 -> 구현 -> 검증 -> maintenance
  (단순하고 고전적인 모델)

  이전 단계로 돌아가는 `loopback` 을 적극 채택하고 있음

  **에자일 모델**

  개개인의 자유성을 존중 (유연하고 가벼운 움직임)을 통하여 민첩한 대응을 중시

  → 을 더 중시

  절차 도구 → `개개인의 상호작용`
  문서 작성 → `돌아가는 소프트웨어`
  계약자와의 딱딱한 관계 → `고객도 절차에 함께 참여`
  계획 고집 → `환경의 변화에 대응하여 알맞은 대책 강구`

  한 실무 인터뷰에서 애자일의 58%는 스크럼 방식을 주로 사용한다고 함. (그만큼 중요)
  스크럼은 다음분이,,,

- 양아영

  ## 스크럼(Scrum)

    1. 제품에 대한 요구사항 수집 → Product Backlog 형태로 유지관리
    2. Product Goal에 맞춰 Product Backlog를 계속 refine 해나감
    3. 이 중 중요도가 높은 것들을 택해 짧은 단위의 sprint를 기반으로 개발활동 이루어짐
    - Sprint 수행
        1. Sprint 플래닝
        2. Sprint goal 정의
        3. backlog를 두고 goal 달성해나가기
        - daily scrum (간단하게 이슈 공유)
        - Sprint 하나 끝날때마다 test/review - 스프린트 회고

  (장점)

    - 스프린트마다 생산되는 실행 가능한 제품을 통해 사용자와 의견 교환 가능
    - 데일리 미팅을 통해 팀원들과 빠른 협조, 조율 가능
    - 스프린트 단위 → 업무 집중도 향상
    - 진행 현황 모니터링 → 신속하게 목표, 결과 추정, 변화 가능

  (단점)

    - 매 스프린트마다 릴리즈를 해야해서 오버헤드가 클 수 있음
    - 데일리 스크럼 시간이 매우 짧음
    - 시간이 짧아 관리보다 working 소프트웨어로 만드는데 집중 → 프로프로세스 품질 평가가 어려움

      → 회고의 중요성


    ## Pair Programming
    
    : 하나의 워크스테이션에서 두 명이 함께 코드 개발
    
    목적 : 잠재적 실패요소를 가능한 빠른 시간에 발견하고 미리 없애는 것
    
    - Driver & navigator
    - 주니어-시니어 효율 높음
- 윤건우

  ### 코드 리뷰

  개발자가 작성한 코드를 다른 개발자가 정해진 방법을 통해서 검토하는 일

  소프트웨어의 품질을 향상, 보장하기 위한 중요한 활동

    - 형태
        - 상급자 검토, 집단 검토, 동료 검토,…
    - 종류
        - 코드 규칙 검사, 실패 검출, 워크 스루, …

  ### 클린 코드

  **전문가들이 표현한 '클린코드'**

  > 1. 한 가지를 제대로 한다.
  >
  >
  > 2. 단순하고 직접적이다.
  >
  > 3. 특정 목적을 달성하는 방법은 하나만 제공한다.
  >
  > 4. 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기 이 세가지가 비결
  >
  > 5. 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행하는 것
  >

    - 의도된 기능을 올바르게 수행한다고 해서 좋은 코드가 만들어진 것은 아님.
    - 소프트웨어는 “살아 있는” 개체로 보는 것이 마땅한 듯 ← 요구사항 변화와 코드 변경이 반복되는 것이 일반적

  ### 클린코드를 만들기 위한 몇 가지 규칙

    1. **네이밍(Naming)**

  > 변수, 클래스, 메소드에 의도가 분명한 이름을 사용한다.
  >

  잘못된 정보를 전달할 수 있는 이름을 사용하지 않는다.

    ```java
    int elapsedTimeInDays;
    int daysSinceCreation;
    int fileAgeInDays;
    ```

    1. **주석달기(Comment)**

  > 코드를 읽는 사람이 코드를 작성한 사람만큼 잘 이해할 수 있도록 도와야 한다.
  >

  주석은 반드시 달아야 할 이유가 있는 경우에만 작성하도록 한다. 즉, 코드를 빠르게 유추할 수 있는 내용에는 주석을 사용하지 않는 것이 좋다.

  설명을 위한 설명은 달지 않는다.

    ```java
    // 주어진 'name'으로 노드를 찾거나 아니면 null을 반환한다.
    // 만약 depth <= 0이면 'subtree'만 검색한다.
    // 만약 depth == N 이면 N 레벨과 그 아래만 검색한다.
    Node* FindNodeInSubtree(Node* subtree, string name, int depth);
    ```

    1. **꾸미기(Aesthetics)**

  > 보기좋게 배치하고 꾸민다. 보기 좋은 코드가 읽기도 좋다.
  >

  규칙적인 들여쓰기와 줄바꿈으로 가독성을 향상시키자.

  일관성있고 간결한 패턴을 적용해 줄바꿈한다.

  메소드를 이용해 불규칙한 중복 코드를 제거한다.

    1. **흐름제어 만들기(Making control flow easy to read)**
    - 왼쪽에는 변수를, 오른쪽에는 상수를 두고 비교

    ```java
    if(length >= 10)
    while(bytes_received < bytest_expected)
    ```

    - 부정이 아닌 긍정을 다루자

    ```java
    if( a == b ) { // a!=b는 부정
    	// same
    } else {
    	// different
    }
    ```

    - if/else를 사용하며, 삼항 연산자는 매우 간단한 경우만 사용
    - do/while 루프는 피하자

    1. **착한 함수(Function)**

  > 함수는 가급적 작게, 한번에 하나의 작업만 수행하도록 작성
  >

  온라인 투표로 예를 들어보자.

  사용자가 추천을 하거나, 이미 선택한 추천을 변경하기 위해 버튼을 누르면 vote_change(old_vote, new_vote) 함수를 호출한다고 가정

    ```jsx
    var vote_changed = function (old_vote, new_vote) {
        
    	var score = get_score();
        
    	if (new_vote !== old_vote) {
    		if (new_vote == 'Up') {
    			score += (old_vote === 'Down' ? 2 : 1);
    		} else if (new_vote == 'Down') {
    			score -= (old_vote === 'Up' ? 2 : 1);
    		} else if (new_vote == '') {
    			score += (old_vote === 'Up' ? -1 : 1);
    		}
    	}
    	set_score(score);
        
    };
    ```

  총점을 변경해주는 한 가지 역할을 하는 함수같지만, 두가지 일을 하고 있다.

    - old_vote와 new_vote의 상태에 따른 score 계산
    - 총점을 계산

  별도로 함수로 분리하여 가독성을 향상시키자

    ```jsx
    var vote_value = function (vote) {
        
        if(vote === 'Up') {
            return +1;
        }
        if(vote === 'Down') {
            return -1;
        }
        return 0;
        
    };
    
    var vote_changed = function (old_vote, new_vote) {
        
        var score = get_score();
        
        score -= vote_value(old_vote); // 이전 값 제거
        score += vote_value(new_vote); // 새로운 값 더함
        set_score(score);
    };
    ```

  ### 코드의 형태적 명확성

    - **문법적 형식**
        - 코딩 규약 준수 여부, 올바르고 명확한 문법을 구사하였는지
    - **구문 의미적 형식**
        - 같은 실행 결과를 낳는 코드 중에서도 생각의 흐름을 더 명확하게 표현하는 코드가 있다.

    ```python
    i = 1; sum = 0
    
    while True:
    	sum += i
    	if i == 10:
    		break
    	i = i + 1
    	
    print("sum = " + str(sum))
    ```

    ```python
    i = 1
    sum = 0
    
    while i <= 10:
    	sum += i
    	i += 1
    	
    print("sum = %d" % sum)
    
    ```

    ```python
    sum = 0
    
    for i in range(1, 11):
    	sum += i
    	
    print("sum = %d" % sum)
    
    ```

  ### 코드 인스펙션 (Code Inspection)

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/c9ba324b-f115-4b1a-90bb-852e5c777f03/Untitled.png)

  제품의 품질을 향상시키기 위해 제품을 실행하지 않고 제품의 소스코드를 확인해 결함을 발견하는 방법.

  리뷰와 마찬가지로 코드 인스펙션을 통해 테스트 수행 이전에 결함을 발견할 수 있으며, 동적 테스트로 발견하기 어려운 결함 및 코드의 유지 보수성 등을 향상시킬 수 있어 필수적으로 수행해야 하는 방법이다.

  프로젝트 초반에 전문 인력을 투입해 초기에 많은 결함을 발견하고 이를 통해 제품의 품질을 향상 시키는 방법이며, 실제로 많은 성공 사례를 가지고 있는 방법 중 하나이다.

  →  오류 발견 및 수정을 가능한 한 빠른 단계에서 하고자 하는 노력 (비용 절감과 생산성 향상)

  **절차 과정**

    1. Planning : 계획 수립
    2. Overview : 교육과 역할 정의
    3. Preparation : 인스펙션을 위한 인터뷰, 산출물, 도구 준비
    4. Meeting : 검토 회의로 각자 역할을 맡아 임무 수행
    5. Rework : 발견한 결함을 수정하고 재검토 필요한지 여부 결정
    6. Follow-up : 보고된 결함 및 이슈가 수정되었는지 확인하고 시정조치 이행

  ### 리팩토링

  점진적으로 반복 수행되는 과정을 통해 코드를 조금씩 개선해나가는 것

  **리팩토링 대상**

    - 메소드 정리 : 그룹으로 묶을 수 있는 코드, 수식을 메소드로 변경함
    - 객체 간의 기능 이동 : 메소드 기능에 따른 위치 변경, 클래스 기능을 명확히 구분
    - 데이터 구성 : 캡슐화 기법을 적용해 데이터 접근 관리
    - 조건문 단순화 : 조건 논리를 단순하고 명확하게 작성
    - 메소드 호출 단순화 : 메소드 이름이나 목적이 맞지 않을 때 변경
    - 클래스 및 메소드 일반화 : 동일 기능 메소드가 여러개 있으면 수퍼클래스로 이동

  **리팩토링 진행 방법**

  아키텍처 관점 시작 → 디자인 패턴 적용 → 단계적으로 하위 기능에 대한 변경으로 진행

- 이정우

  **좋은 소프트웨어를 만들기 위해 (쉬어가는 타임)**
- ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/bcee6bf9-30a8-402c-91c4-6861166e8f4c/Untitled.png)

    - **Good Code (좋은 코드)**
        - 코드 리뷰 문 앞에 "WTF"라는 반응이 두 번만 나타남.
        - 이는 좋은 코드가 이해하기 쉽고, 문제가 적어 코드 리뷰어가 "WTF"라고 반응하는 일이 거의 없다는 것을 의미
    - **Bad Code (나쁜 코드)**
        - 코드 리뷰 문 앞에 "WTF"라는 반응이 여러 번 나타남.
        - 이는 나쁜 코드가 이해하기 어렵고, 문제가 많아 코드 리뷰어가 자주 "WTF"라고 반응하게 된다는 것을 의미
    - WTF

      "What The F***"의 약어로, 놀라움이나 혼란, 실망 등을 표현하는 강한 감탄사


    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bd96b46c-359f-495d-8a5b-33df5e09796a/f407e1dc-9983-4538-a339-d73c38d6ecbe/Untitled.png)
    
    클린코드 ≠ 짧은코드(한줄코드)가 아님을 숙지 
    
    → 나보다 코드를 보는 다른 개발자들이 이해하기 쉬운코드 = 클린코드



프로그래머스<br>
https://school.programmers.co.kr/learn/courses/30/lessons/12978

프로그래머스<br>
https://school.programmers.co.kr/learn/courses/30/lessons/72413

백준<br>
https://www.acmicpc.net/problem/1916

백준<br>
https://www.acmicpc.net/problem/11657